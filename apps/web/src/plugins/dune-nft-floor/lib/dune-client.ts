
    // Dune Analytics API Client
    // Generated by [N]skills - Feature: nft-floor
    
    const DUNE_API_BASE = 'https://api.dune.com/api/v1';
    
    // Core Types
    export interface DuneExecuteParams {
      sql: string;
      performance?: 'medium' | 'large';
      params?: Record<string, string | number>;
    }
    
    export interface DuneExecutionResult {
      execution_id: string;
      state: 'QUERY_STATE_PENDING' | 'QUERY_STATE_EXECUTING' | 'QUERY_STATE_COMPLETED' | 'QUERY_STATE_FAILED' | 'QUERY_STATE_CANCELLED';
    }
    
    export interface DuneQueryResult<T = Record<string, unknown>> {
      execution_id: string;
      query_id: number;
      state: string;
      result: {
        rows: T[];
        metadata: {
          column_names: string[];
          column_types: string[];
          row_count: number;
          result_set_bytes: number;
          total_row_count: number;
        };
      };
    }
    
    
export interface NFTFloorData {
  collection_address: string;
  floor_price_eth: number;
  floor_price_usd: number;
  volume_24h: number;
  sales_count_24h: number;
  timestamp: string;
}
    
    class DuneClient {
      private apiKey: string;
      private cache: Map<string, { data: unknown; expiry: number }> = new Map();
    
      constructor() {
        const key = process.env.NEXT_PUBLIC_DUNE_API_KEY ?? process.env.DUNE_API_KEY;
        if (!key) {
          console.warn('Missing DUNE_API_KEY environment variable');
        }
        this.apiKey = key ?? '';
      }
    
      private getCached<T>(key: string): T | null {
        const cached = this.cache.get(key);
        if (cached && cached.expiry > Date.now()) {
          return cached.data as T;
        }
        this.cache.delete(key);
        return null;
      }
    
      private setCache(key: string, data: unknown, ttlMs: number): void {
        this.cache.set(key, { data, expiry: Date.now() + ttlMs });
      }
    
      
  /**
   * Execute a SQL query on Dune
   */
  async executeSQL(params: DuneExecuteParams): Promise<DuneExecutionResult> {
    const response = await fetch(`${DUNE_API_BASE}/sql/execute`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-DUNE-API-KEY': this.apiKey,
      },
      body: JSON.stringify({
        sql: params.sql,
        performance: params.performance ?? 'medium',
        ...(params.params && { query_parameters: params.params }),
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Get execution status
   */
  async getExecutionStatus(executionId: string): Promise<DuneExecutionResult> {
    const response = await fetch(`${DUNE_API_BASE}/execution/${executionId}/status`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Get execution results
   */
  async getExecutionResults<T = Record<string, unknown>>(executionId: string): Promise<DuneQueryResult<T>> {
    const response = await fetch(`${DUNE_API_BASE}/execution/${executionId}/results`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Execute query and wait for results
   */
  async executeAndWait<T = Record<string, unknown>>(
    params: DuneExecuteParams,
    options?: { pollInterval?: number; timeout?: number; cacheTtl?: number }
  ): Promise<DuneQueryResult<T>> {
    const cacheKey = JSON.stringify(params);
    const cached = this.getCached<DuneQueryResult<T>>(cacheKey);
    if (cached) return cached;

    const pollInterval = options?.pollInterval ?? 1000;
    const timeout = options?.timeout ?? 60000;
    const startTime = Date.now();

    const execution = await this.executeSQL(params);
    
    while (Date.now() - startTime < timeout) {
      const status = await this.getExecutionStatus(execution.execution_id);
      
      if (status.state === 'QUERY_STATE_COMPLETED') {
        const results = await this.getExecutionResults<T>(execution.execution_id);
        if (options?.cacheTtl) {
          this.setCache(cacheKey, results, options.cacheTtl);
        }
        return results;
      }
      
      if (status.state === 'QUERY_STATE_FAILED' || status.state === 'QUERY_STATE_CANCELLED') {
        throw new Error(`Query ${status.state}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    throw new Error('Query execution timeout');
  }
      
      
  /**
   * Get NFT collection floor price
   */
  async getNFTFloor(
    collectionAddress: string,
    blockchain: string,
    cacheTtl = 300000
  ): Promise<NFTFloorData | null> {
    const sql = `
      SELECT 
        nft_contract_address as collection_address,
        MIN(amount_raw / 1e18) as floor_price_eth,
        MIN(amount_usd) as floor_price_usd,
        SUM(CASE WHEN block_time >= NOW() - INTERVAL '24' HOUR THEN amount_usd ELSE 0 END) as volume_24h,
        COUNT(CASE WHEN block_time >= NOW() - INTERVAL '24' HOUR THEN 1 END) as sales_count_24h,
        MAX(block_time) as timestamp
      FROM nft.trades
      WHERE nft_contract_address = LOWER('${collectionAddress}')
        AND blockchain = '${blockchain}'
        AND block_time >= NOW() - INTERVAL '7' DAY
      GROUP BY nft_contract_address
    `;

    const result = await this.executeAndWait<NFTFloorData>({ sql }, { cacheTtl });
    return result.result.rows[0] ?? null;
  }
    }
    
    // Export singleton instance
    export const duneClient = new DuneClient();
    
    // Export class for custom instances
    export { DuneClient };
  